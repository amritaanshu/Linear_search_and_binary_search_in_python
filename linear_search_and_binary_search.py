# -*- coding: utf-8 -*-
"""linear_search_and_binary_search.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/151f9C67e6l0-qIPI5qqyJRQQ679SY8Ml
"""

def locate_card(cards, query):
    position = 0
    print('cards:', cards)
    print('query:', query)

    while position < len(cards):
        print('position:', position)

        if cards[position] == query:
            return position  # Fixed typo here
        position += 1

    return -1  # Moved this outside the loop (cleaner)

test_cases = [
    # Format: (cards list, query, expected result)

    # 1. Normal case, element present in middle
    ([13, 11, 9, 7, 5, 3, 1], 7, 3),

    # 2. Element at beginning
    ([13, 11, 9, 7, 5, 3, 1], 13, 0),

    # 3. Element at end
    ([13, 11, 9, 7, 5, 3, 1], 1, 6),

    # 4. Element not present
    ([13, 11, 9, 7, 5, 3, 1], 4, -1),

    # 5. Empty list
    ([], 4, -1),

    # 6. Single element - present
    ([4], 4, 0),

    # 7. Single element - absent
    ([3], 4, -1),

    # 8. Multiple occurrences (should return first match)
    ([4, 4, 4, 4], 4, 0)
]

# Run Tests
for idx, (cards, query, expected) in enumerate(test_cases):
    print(f"\nTest Case {idx + 1}:")
    result = locate_card(cards, query)
    print(f"Expected: {expected}, Got: {result}")
    assert result == expected, f"Test case {idx+1} failed!"

def locate_card(cards, query):
  lo, hi= 0, len(cards)-1

  while lo<=hi:
    mid = (lo + hi)//2
    mid_number =  cards[mid]
    print("lo:", lo, "hi:", hi, "mid:", mid, "mid_number:", mid_number)
    if mid_number == query:
      return mid
    elif mid_number < query:
      hi = mid - 1
    elif mid_number > query:
      lo = mid + 1
  return -1

# Test Cases
tests = [
    ([13, 11, 9, 7, 5, 3, 1], 7, 3),
    ([13, 11, 9, 7, 5, 3, 1], 13, 0),
    ([13, 11, 9, 7, 5, 3, 1], 1, 6),
    ([13, 11, 9, 7, 5, 3, 1], 4, -1),
    ([], 4, -1),
    ([4], 4, 0),
    ([3], 4, -1),
    ([4, 4, 4, 4], 4, "any")  # Duplicates case
]

# Run tests
for i, (cards, query, expected) in enumerate(tests):
    print(f"\nTest {i+1}")
    result = locate_card(cards, query)

    if expected == "any":
        assert result in range(len(cards)), "Test failed"
    else:
        assert result == expected, "Test failed"

    print(f"Result: {result}")

#binary search more faster than linear search for very big lists
import random
import time

# Linear search (your first version)
def linear_search(cards, query):
    position = 0
    while position < len(cards):
        if cards[position] == query:
            return position
        position += 1
    return -1

# Binary search (your second version)
def binary_search(cards, query):
    lo, hi = 0, len(cards)-1
    while lo <= hi:
        mid = (lo + hi) // 2
        mid_number = cards[mid]

        if mid_number == query:
            return mid
        elif mid_number < query:
            hi = mid - 1
        else:
            lo = mid + 1
    return -1

# Create large test list
n = 10**6  # 1 million elements
large_list = list(range(n, 0, -1))  # Descending from 1,000,000 to 1

# Pick a random query in the list
query = random.randint(1, n)

# Test Linear Search
start = time.time()
result_linear = linear_search(large_list, query)
end = time.time()
print(f"Linear Search: Found at index {result_linear} in {end - start:.4f} seconds")

# Test Binary Search
start = time.time()
result_binary = binary_search(large_list, query)
end = time.time()
print(f"Binary Search: Found at index {result_binary} in {end - start:.4f} seconds")

def binary_search(lo, hi, condition):
  while lo<=hi:
    mid = (lo + hi)//2
    result = condition(mid)
    if result == 'found':
      return mid
    elif result == 'left':
      hi = mid - 1
    else:
      lo = mid + 1
  return -1
  #generic binary search

def binary_search(lo, hi, condition):
    while lo <= hi:
        mid = (lo + hi) // 2
        result = condition(mid)

        if result == 'found':
            return mid
        elif result == 'left':
            hi = mid - 1
        else:  # 'right'
            lo = mid + 1

    return -1

def first_position(nums, target):
    def condition(mid):
        if nums[mid] == target:
            if mid > 0 and nums[mid-1] == target:
                return 'left'
            return 'found'
        elif nums[mid] < target:
            return 'right'
        else:
            return 'left'
    return binary_search(0, len(nums)-1, condition)

def last_position(nums, target):
    def condition(mid):
        if nums[mid] == target:
            if mid < len(nums)-1 and nums[mid+1] == target:
                return 'right'
            return 'found'
        elif nums[mid] < target:
            return 'right'
        else:
            return 'left'
    return binary_search(0, len(nums)-1, condition)

def first_and_last_position(nums, target):
    return first_position(nums, target), last_position(nums, target)